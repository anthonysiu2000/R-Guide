This program is a simulation of pathfinding algorithms on a 2D Map, considering an agent that can move in 8 directions
and a Map with altitude values.

Map generation is hard-coded to a 100-by-100 Map.
Each point in the map has altitude values, which are used to limit the movement of the agent.
The agent is only able to move to points above or below its current altitude by 1, or at the same altitude.

There are several features of the program in the form of buttons and map interactivity:
1. Advance Robot
	This option will only work when a path is generated by button 3 or 4. This option will move the agent along the visualized path one-by-one.
2. New 20x20
	This option, when clicked, will generate a new map. Currently, map size is hard-coded to 100x100
3. Dijkstra Find Path
	This option, when clicked, will use the Dijkstra algortihm to find the best path from the agent's location to the endpoint.
	The command line will output the amount of time the program took, and the amount of time the algorithm took.
4. A* Find Path
	This option, when clicked, will use the A* algortihm using a Octile heuristic to find the best path from the agent's location to the endpoint.
	The command line will output the amount of time the program took, and the amount of time the algorithm took.
5. Create Obstacles
	When this option is turned on (this is a toggle button), pressing a point on the visualization will make that point an untraversable point
6. Toggle Limited Visibility
	When this option is turned on, the pathfinding buttons will only consider the hard-coded 11by11 square around it when calculating a path to the endpoint.

0. The user is able to click on the visualization, particularly the agent. Once the agent is selected, it is possible to select an adjacent tile for the agent to move to.
	If the attempted move is illegal, the move will not go through.


Possible Additions to add in the future:
1. Create some sort of "memory" for the robot such that it will remember the altitude values of the points around it. 
	Thus, as the agent moves towards the goal when not omniscient, the robot will recall from its past the points that were around it.
2. Create multiple additional robots that are able to collaborate in finding the path to the goal.
3. Allow more omni-directional movement, possibly by moving away fromm python, or finding special packages
